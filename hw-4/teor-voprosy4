(1)
    -литерал {}

    -конструктор встроенный в Object 
// let user = new Object()

    -функция-конструктор 
    — это обычная функция, которую вызывают с new. Она создаёт новый объект и присваивает ему свойства.
// function User(name, age) {
//     this.name = name;
//     this.age = age;
//     this.sayHi = function() {
//       console.log(`Привет, меня зовут ${this.name}`);
//     };
//   }
  
//   const user1 = new User("Боб", 40);

    -классы
    это современный синтаксис(синтаксический сахар) для создания объектов, основанный на функциях-конструкторах, но более удобный.
// class User {
//     constructor(name, age) {
//       this.name = name;
//       this.age = age;
//     }
      
//     sayHi() {
//        console.log(`Привет, меня зовут ${this.name}`);
//     }
// }
// const user3 = new User("Дмитрий", 28);


    -Object.create()
    С помощью Object.create(proto, ?properties), где proto-это прототип для нового
объекта, а properties - объект, описывающийсвойства создаваемого объекта в виде
“название: дескриптор”. 


    -JSON.parse()
    создает объект из строки

    -Object.assign(destObj, source1, source2...)
    копирует свойства из одного или нескольких объектов в новый.


    (2)
    перебрать в for ... in (включая унаследованные вернет. остальные способы унаследованные не вернут)

    Object.keys(obj) – получить массив ключей
    Возвращает только перечисляемые собственные свойства.

    Object.values(obj) – получить массив значений перечисляемых свойств

    Object.entries(obj) – Получение массива [ключ, значение]
Возвращает массив массивов пар [ключ, значение] для перечисляемых собственных свойств.

    Object.getOwnPropertyNames(obj) – Возвращает массив, содержащий имена всех переданных объекту собственных перечисляемых и не перечисляемых свойств.

    Object.getOwnPropertySymbols() Возвращает массив всех символьных свойств, найденных непосредственно в переданом объекте 

    (3), (4)
    поверхностное
    {...objToCopy}
    Object.assign(dest, src1, src2...)

    вложенное копирование
    _.cloneDeep(obj) из библиотеки JavaScript lodash.
    глобальный метод structuredClone()
    самописная рекурсивная функция
    Использование методов JSON.stringify() и JSON.parse() (неоднозначныйвариант, т.к. тоже имеет свои подводные камни.


    (5)
        Object.seal() запрещает добавлять и удалять свойства из объекта, но разрешает изменять существующие.

    (6)
    Object.freeze() делает объект неизменяемым. Это означает, что после его применения:
Нельзя изменять значения существующих свойств.
Нельзя добавлять новые свойства.
Нельзя удалять существующие свойства.
Свойства становятся неконфигурируемыми и только для чтения (то есть configurable: false, writable: false).

(7)
Метод Object.defineProperty() позволяет определять или изменять дескрипторы свойств объекта. С его помощью можно задавать такие параметры, как:

writable — можно ли изменять значение свойства.
enumerable — будет ли свойство показываться при перечислении (например, в for...in или Object.keys()).
configurable — можно ли изменять дескриптор свойства (например, можно ли изменить его тип или удалить его).
value — значение свойства.
get — геттер для свойства.
set — сеттер для свойства.

Object.defineProperty(obj, prop, descriptor);
obj: объект, в котором добавляется или изменяется свойство.
prop: имя свойства, которое нужно создать или изменить.
descriptor: объект, который описывает поведение свойства. Он может содержать такие параметры, как value, writable, enumerable, configurable, get, set.

(8)
Object.create(prototype, propertiesObject);

prototype — объект, который будет использоваться как прототип нового объекта. Это может быть любой объект, в том числе null. Если параметр опущен, по умолчанию используется Object.prototype.

propertiesObject (необязательный параметр) — объект с дескрипторами свойств, которые будут добавлены в новый объект. 
Этот параметр аналогичен тому, как работает Object.defineProperty(), и позволяет устанавливать дополнительные характеристики для свойств (например, value, writable, configurable, enumerable).

Ключевые особенности Object.create()
Наследование: Новый объект, созданный с помощью Object.create(), имеет прототип, который можно указать, и может наследовать методы и свойства от этого прототипа.
Чистые объекты: Если в качестве прототипа передать null, создается объект без прототипа, что может быть полезно в некоторых случаях (например, для создания простых объектов без методов).
Не мутирует оригинальный объект: Object.create() не изменяет исходный объект, он лишь создает новый объект, унаследовавший его.

(9)
Метод Object.setPrototypeOf() позволяет изменить прототип (или внутреннее свойство [[Prototype]]) существующего объекта. Это дает возможность изменять прототип объекта после его создания.
Object.setPrototypeOf(obj, prototype);
obj: объект, чей прототип нужно изменить.
prototype: новый прототип для объекта. Это может быть объект или null.

(10)
Метод Object.getPrototypeOf() позволяет получить прототип (внутреннее свойство [[Prototype]]) объекта. Этот метод возвращает объект, который является прототипом переданного объекта.
Object.getPrototypeOf(obj);
obj: объект, прототип которого необходимо получить.

(12)
Object.getPrototypeOf(obj) — рекомендуемый способ
Этот метод возвращает прототип переданного объекта.

__proto__ (устаревший, но рабочий способ)
Все объекты (кроме тех, у которых Object.create(null)) имеют свойство __proto__, которое указывает на их прототип.

(13)
Метод Object.create(prototype) создает новый объект, используя переданный объект в качестве прототипа.
Установка прототипа с Object.setPrototypeOf() медленный способ
Функция-конструктор создаёт объекты с общим прототипом.
Использование class (современный способ)
Синтаксический сахар над функцией-конструктором:

(14)
В JavaScript каждое свойство объекта имеет дескриптор, который определяет его поведение. 
С помощью дескрипторов можно настраивать свойства: делать их недоступными для изменения, скрывать из перечисления или запретить удаление.

Object.getOwnPropertyDescriptor()
Object.defineProperty()

(15)
Самый удобный и правильный способ — использовать Object.create(null).
Можно взять существующий объект и убрать у него прототип с помощью Object.setPrototypeOf().

(16)
Оба метода принимают колбэк, который вызывается для каждого элемента. 
Разница в том, что метод forEach() ничего не возвращает, а метод map() возвращает новый массив с результатами вызова колбэка на каждом исходном элементе. 
Если переданный колбэк ничего не возвращает в новом массиве появится undefined

Используя map() вы можете создавать цепочки вызовов. Если же вы будете использовать forEach() так сделать не получится.

(17)
мутирующие:
push()	Добавляет элемент(ы) в конец массива
pop()	Удаляет последний элемент массива
unshift()	Добавляет элемент(ы) в начало массива
shift()	Удаляет первый элемент массива
splice()	Удаляет/добавляет/заменяет элементы по индексу
sort()	Сортирует массив (изменяя его)
reverse()	Переворачивает порядок элементов
fill()	Заполняет массив указанным значением

не мутирует
map()	Преобразует каждый элемент и создает новый массив
filter()	Фильтрует массив, создавая новый
slice()	Возвращает копию части массива
concat()	Объединяет массивы в новый массив
reduce()	Преобразует массив в одно значение
flat()	Разворачивает вложенные массивы
flatMap()	Комбинация map() и flat()
toSorted()	Возвращает отсортированную копию массива (ES2023)
toReversed()	Возвращает перевернутую копию массива (ES2023)
toSpliced()	Возвращает измененный массив без изменения оригинала (ES2023)

(18)
Они используются для вычисления единого значения на основе всего массива.

Синтаксис:

let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

Аргументы:

accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
item – очередной элемент массива,
index – его позиция,
array – сам массив.
При вызове функции результат её предыдущего вызова передаётся на следующий вызов в качестве первого аргумента.

Так, первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих вызовов функции. По окончании он становится результатом reduce.

(19) (21)
arr.some(fn)/arr.every(fn) проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.

Эти методы ведут себя примерно так же, как операторы || и &&: если fn возвращает истинное значение, arr.some() немедленно возвращает true и останавливает перебор остальных элементов; 
если fn возвращает ложное значение, arr.every() немедленно возвращает false и также прекращает перебор остальных элементов.

(20)
arr.includes(item, from) ищет item в массиве arr начиная с индекса from и возвращает true, если поиск успешен.

(22)
Function Declaration (Объявление функции)
Function Expression (Функциональное выражение)
Arrow Function (Стрелочная функция)

(23)
нет собственного this. Стрелочная функция не создаёт своё собственное значение this, а наследует его из окружающего контекста (лексическое this).
Если тело функции состоит из одного выражения, можно опустить {} и return
нельзя использовать с new
нет arguments,  но можно использовать ...args

(24)
Hoisting:

FD поднимается и доступна до объявления.
FE не поднимается, доступна только после объявления.
Синтаксис:

FD: function name() {}.
FE: const name = function() {}.
Использование:

FD можно вызывать в любом месте.
FE можно вызывать только после объявления.
Анонимность:

FD всегда именованная.
FE может быть анонимной.
Рекурсия:

FD поддерживает рекурсию (сама себя может вызвать).
FE поддерживает рекурсию, но через имя переменной.
Используй FD для глобальных функций и FE для локальных и колбэков.

(25)
IIFE (Immediately Invoked Function Expression) — это немедленно вызываемое функциональное выражение. Это такая функция, которая создаётся и сразу же выполняется.

Синтаксис:
javascript
Копировать
Редактировать
(function() {
  // код функции
})();
Или с использованием стрелочной функции:

javascript
Копировать
Редактировать
(() => {
  // код функции
})();

Изоляция области видимости:
IIFE создаёт свою собственную локальную область видимости, что позволяет избежать загрязнения глобального пространства переменными и функциями. Это полезно, чтобы избежать конфликтов в больших приложениях.
Закрытие (замыкание):
IIFE полезны для создания замыканий, где внутренние данные остаются доступными только внутри функции.
Однократное выполнение:
IIFE позволяет выполнить код один раз, сразу после его определения, что удобно, например, при инициализации или настройке.

(26)
Глобальные переменные:
Это переменные, которые объявляются вне функций или блоков кода. Они доступны во всей программе, в любой функции или области.

Локальные переменные:
Это переменные, которые объявляются внутри функций или блоков кода. Они доступны только внутри этих функций или блоков.